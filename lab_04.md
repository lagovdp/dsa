# Стек, Очередь, Дек


### Цель работы

Изучение структур данных &laquo;Стек&raquo;, &laquo;Очередь&raquo;, &laquo;Дек&raquo;, а также основных операций над ними.

### Продолжительность и сроки сдачи

Продолжительность работы: - 4 часа.

Мягкий дедлайн (10 баллов): 20.10.2025

Жесткий дедлайн (5 баллов): 27.11.2025


## Краткие теоретические сведения

Линейные списки являются фундаментальной структурой данных, на основе которой эффективно реализуются другие абстрактные типы данных (АТД). В данном разделе рассматривается реализация **стека**, **очереди** и **дека** с использованием как односвязных, так и двусвязных списков.

### Стек (Stack)

**Стек** — это структура данных, работающая по принципу **LIFO (Last-In, First-Out)** — «последним пришёл — первым ушёл».

**Основные операции:**

* `push(x)` — добавление элемента `x` на вершину стека.
* `pop()` — удаление и возврат элемента с вершины стека.
* `peek()` (или `top()`) — возврат элемента с вершины стека без удаления.
* `isEmpty()` — проверка стека на пустоту.

**Реализация на односвязном списке:**

Вершиной стека является **голова** списка. Добавление и удаление элемента выполняются строго с головы.

* **`push(x)`**: Создать новый узел `new_node` со значением `x`. Установить `new_node.next = head`. Переместить голову на `new_node`.
* **`pop()`**: Если список пуст — ошибка. Иначе: сохранить значение `head.data`, переместить голову на `head.next`, вернуть сохранённое значение.
* **Сложность операций:** `push`, `pop`, `peek`, `isEmpty` выполняются за **O(1)**.

### Очередь (Queue)

**Очередь** — это структура данных, работающая по принципу **FIFO (First-In, First-Out)** — «первым пришёл — первым ушёл».

**Основные операции:**

* `enqueue(x)` (или `push`) — добавление элемента `x` в конец очереди.
* `dequeue()` (или `pop`) — удаление и возврат элемента из начала очереди.
* `peek()` — возврат элемента из начала очереди без удаления.
* `isEmpty()` — проверка очереди на пустоту.

**Реализация на односвязном списке с указателем на хвост:**

Для эффективного добавления в конец необходимо хранить два указателя: `head` (начало очереди) и `tail` (конец очереди).
* **`enqueue(x)`**: Создать новый узел `new_node`. Если очередь пуста, установить `head = tail = new_node`. Иначе: установить `tail.next = new_node`, затем переместить `tail` на `new_node`.
* **`dequeue()`**: Если очередь пуста — ошибка. Иначе: сохранить значение `head.data`, переместить голову на `head.next`. *Важно:* если после этого голова стала `null`, то и `tail` нужно установить в `null` (очередь опустела).

**Сложность операций:** `enqueue`, `dequeue`, `peek`, `isEmpty` выполняются за **O(1)**. 

### Дек (Deque — Double-Ended Queue)

**Дек** — это двусторонняя очередь, позволяющая добавлять и удалять элементы как в начале, так и в конце.

**Основные операции:**

* `pushFront(x)` — добавление в начало.
* `pushBack(x)` — добавление в конец.
* `popFront()` — удаление из начала.
* `popBack()` — удаление из конца.
* `peekFront()`, `peekBack()` — просмотр начала/конца.

**Реализация на двусвязном списке:**

Для эффективного удаления с конца (`popBack`) односвязного списка недостаточно, так как у его последнего элемента нет ссылки на предыдущий. Поэтому дек оптимально реализуется на **двусвязном списке** с двумя указателями: `head` и `tail`.
    *   **`pushFront(x)`**: Аналогично добавлению в начало двусвязного списка. Установить связи между `new_node` и `head`.
    *   **`pushBack(x)`**: Аналогично добавлению в конец двусвязного списка. Установить связи между `tail` и `new_node`.
    *   **`popBack()`**: Если дек не пуст, переместить `tail` на `tail.prev`, отсечь старый хвост. Корректно обработать случай, когда в деке只有一个 элемент.
    *   **Сложность операций:** Все основные операции (`pushFront`, `pushBack`, `popFront`, `popBack`) выполняются за **O(1)**.



#### Сравнение реализаций на списках и массивах

| Критерий | Реализация на **списках** | Реализация на **массивах** (динамических) |
| :--- | :--- | :--- |
| **Сложность операций** | Все операции **O(1)** (амортизированные для массива) | `pushBack`/`popBack` — **O(1)***, `pushFront`/`popFront` — **O(n)** |
| **Память** | **Больше**: память на хранение указателей. | **Меньше**: память только на данные (но может быть избыточное выделение). |
| **Локализация данных** | **Плохая**: узлы в случайных местах памяти (кэш-промахи). | **Отличная**: данные лежат рядом (кэш-дружественность). |
| **Динамичность** | **Истинно динамическая**: каждый элемент выделяется отдельно. | **Динамическая с резервированием**: требует периодического дорогого копирования (reallocation). |

**Вывод:** Реализация стека, очереди и дека на связных списках является **более универсальной и надёжной** с точки зрения сложности операций, так как не требует операций копирования и расширения массива. Она гарантирует **константное время** выполнения для всех ключевых операций. Однако она проигрывает в потреблении памяти и скорости доступа из-за плохой локализации данных. Реализация на массивах (особенно для стека и очереди с кольцевой организацией) часто быстрее на практике для задач, где размер данных大致 известен, благодаря кэш-дружественности.


## Задания


### Задание 1

**1.** Реализовать стек на основе массива.

**2.** Реализовать стек на основе связного списка.

**3.** Реализовать очередь на основе массива.

**4.** Реализовать очередь на основе связного списка.

**5.** Реализовать дек на основе массива.

**6.** Реализовать дек на основе связного списка.

Требования:
 - структуры данных должны быть реализованы в виде классов,  наследующих соответсвующие базовые классы;
 - каждая операция должна быть реализована как метод класса.


### Задание 2

Используя операции со стеком, написать программу, проверяющую своевременность закрытия скобок «(, ), [, ] ,{, }» в строке символов (строка состоит из одних скобок этих типов).

В процессе решения анализируются символы строки. Если встречена одна из открывающихся скобок, то она записывается в стек. При обнаружении
закрывающейся скобки, соответствующей скобке, находящейся в вершине стека, последняя удаляется. При несоответствии скобки выдается сообщение об ошибке, которое фиксируется в логической переменной.


### Задание 3

Написать программу вычисления значения выражения, представленного в обратной польской записи (в постфиксной записи). Выражение состоит из цифр от 1 до 9 и знаков операции.

| Обычная (инфиксная) запись | Обратная польская (постфиксная) запись |
|:---|:---|
| (a+b) * c    | a b + c *       |
|  a + (b+c)*d | a b c + d * +   |

Просматривая строку, анализируем очередной символ, если это:
 - цифра, то записываем ее в стек;
 - знак, то читаем два элемента из стека, выполняем математическую операцию, определяемую этим знаком, и заносим результат в стек.

После просмотра всей строки в стеке должен оставаться один элемент, он и является решением задачи.


### Задание 4

Реализовать перевод математических выражений из инфиксной в постфиксную форму записи.



### Методика и порядок выполнения работы

Для успешного выполнения и ащиты лабораторной работ, необходимо выполнить следующие этапы:

1. изучить теоретический материал по теме лабораторной работы (лекции, учебники);
2. написать программу для каждого задания;
3. оформить отчет по лабораторной работе;
4. защитить лабораторную работу.


### Содержание отчета и его форма

Отчет по лабораторной работе должен содержать:

1. Номер и название лабораторной работы; цель и задачи лабораторной работы.

2.  Словесная постановка задачи.
    В этом подразделе проводится полное описание задачи.
    Описывается суть задачи, анализ входящих в нее переменных, возможные ограничения, анализ условий
    при которых задача имеет решение (не имеет решения), анализ ожидаемых результатов;

3.  Листинг программного кода с комментариями, показывающие порядок выполнения лабораторной работы, и результаты, полученные в ходе её выполнения.

4. Выводы по лабораторной работе.


## Контрольные вопросы

1.  Дайте определение стека. Сформулируйте принцип, по которому он работает (LIFO).
2.  Дайте определение очереди. Сформулируйте принцип, по которому она работает (FIFO).
3.  Дайте определение дека. Чем он принципиально отличается от стека и очереди?
4.  Перечислите основные операции для каждого АТД:
    *   Стек (`push`, `pop`, `peek`, `isEmpty`)
    *   Очередь (`enqueue`, `dequeue`, `peek`, `isEmpty`)
    *   Дек (`pushFront`, `pushBack`, `popFront`, `popBack`, `peekFront`, `peekBack`)
5.  Почему односвязный список идеально подходит для реализации стека? Какую роль голова списка играет в этой реализации?
6.  Опишите алгоритм операции `push` для стека, реализованного на односвязном списке.
7.  Опишите алгоритм операции `pop` для стека, реализованного на односвязном списке.
8.  Почему для эффективной реализации очереди на списке необходимо хранить два указателя (`head` и `tail`)? Что произойдет, если хранить только `head`?
9.  Опишите пошагово алгоритм операции `enqueue` для очереди, реализованной на односвязном списке с `tail`.
10. Опишите алгоритм операции `dequeue`. Почему в этой операции важно проверять, не стала ли очередь пустой после удаления элемента?
11. Объясните, почему для реализации дека чаще всего выбирают двусвязный список, а не односвязный.
12. Опишите алгоритм операции `popBack` для дека, реализованного на двусвязном списке. Как обрабатывается случай, когда в деке остается один элемент?
13. В чем заключаются преимущества и недостатки реализации стека на динамическом массиве по сравнению со списком?
14. Что такое "кольцевой буфер" (циклический массив) и как он позволяет эффективно реализовать очередь на массиве?
15. Почему операции `pushFront` и `popFront` для дека на обычном массиве имеют сложность O(n)?
16. Заполните таблицу асимптотической сложности основных операций. Укажите сложность для реализаций на списках и на массивах*.
    | Операция | Стек (список) | Очередь (список) | Дек (двусвязный список) | Дек (массив) |
    | :--- | :---: | :---: | :---: | :---: |
    | `push` / `enqueue` / `pushBack` | | | | |
    | `pop` / `dequeue` / `popBack` | | | | |
    | `pushFront` | — | — | | |
    | `popFront` | — | — | | |
    | `peek` | | | | O(1) |
    | `isEmpty` | | | | O(1) |
    *Для массива учитывайте амортизированную сложность.
17. Объясните, почему все основные операции дека на двусвязном списке имеют константную сложность O(1).
18. Приведите 2-3 реальных примера использования стека в программировании и компьютерных науках.
19. Приведите 2-3 реальных примера использования очереди.
20. Для чего может быть полезен дек? Приведите пример.
21. **Задача на знание стека:** Как с помощью стека можно проверить корректность скобочной последовательности? Опишите алгоритм.
22. **Задача на знание очереди:** Какова роль очереди в алгоритме "поиск в ширину" (BFS) в графе?
23. Дан следующий порядок операций со стеком: `push(1)`, `push(2)`, `pop()`, `push(3)`, `push(4)`, `pop()`, `pop()`. В каком порядке будут извлечены элементы?
24. Дан следующий порядок операций с очередью: `enqueue(1)`, `enqueue(2)`, `dequeue()`, `enqueue(3)`, `enqueue(4)`, `dequeue()`, `dequeue()`. В каком порядке будут извлечены элементы?
25. В чем главная ошибка реализации очереди на односвязном списке, если при удалении элемента (`dequeue`) не обновлять указатель `tail` в случае, когда очередь становится пустой?
26. Почему реализация стека на массиве может в отдельные моменты иметь сложность операции `push` O(n), хотя в среднем она считается O(1)?
27. Какое преимущество с точки зрения памяти дает реализация на массиве? А какое — на списке?
28. Когда предпочтительнее использовать реализацию на списках, а когда — на массиве?


### Список литературы

1. Кнут, Д. Э. Искусство программирования: пер. с англ. / Д. Э. Кнут . - 3-е изд. - Москва : Вильямс, 2007. - Т. 1 : Основные алгоритмы, 2007. - 720 с. : ил.. - Прил.: с. 683-691. - Предм.-имен. указ.: с. 692-712. - ISBN 5-8459-0080-8.
2. Кнут, Д. Э. Искусство программирования / Д. Э. Кнут ; под общ. ред. Ю. В. Козаченко. - 2-е изд. - М. : Вильямс, 2009. - (Классический труд : Исправленное и дополненное издание). Т. 3 : Сортировка и поиск. - , 2009. - 823 с. : ил.. - Прил.: с. 794-803. - . - Предм.-имен. указ.: с. 804-822 - ISBN 978-5-8459-0082-1.
3. Кормен, Т. Алгоритмы: Построение и анализ / Т. Кормен, Ч. Лейхерсон, Р. Риверст. – М.: МЦМНО, 2002.
4. Давыдов, В. Г.  Программирование и основы алгоритмизации: учеб.
пособие для вузов / В. Г. Давыдов. - М. : Высш. шк., 2003. - 447 с. : ил - ISBN 5-06-
004432-7.
5. Ахо, А. Построение и анализ вычислительных алгоритмов / А. Ахо, Дж. Хопкрофт, Дж. Ульмен. – М.: Мир, 1989. – 369с.
6. Никлаус Вирт Алгоритмы и структуры данных. – Санкт-Петербург: «Невский диалект», 2001.
